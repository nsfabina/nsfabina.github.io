<!doctype html>

<html lang="en">

<head>
  <title>Regression to the Fabean</title>
  <meta charset="utf-8">
  <meta name="author" content="Nicholas Fabina">
  <link rel="stylesheet" href="../css/style.css">
  <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js?lang=python"></script>
</head>

<body>

<div id="header-wrapper">
  <div id="header">
    <h4>Regression to the Fabean
      <span style="float:right;">Nicholas Fabina</span>
    </h4>
  </div>
</div>

<div id="menu-wrapper">
  <div id="menu-main">
    <ul>
      <li><a href="../index.html">About</a></li>
      <li><a class="selected" href="../blog.html">Blog</a></li>
      <li><a href="../resume.html">Resume</a></li>
      <li><a href="../colleagues.html">Colleagues</a></li>
      <li><a href="../contact.html">Contact</a></li>
    </ul>
  </div>
</div>

<div id="footer-wrapper">
  <div id="footer-box">
    <ul>
        <li><div class="email"><a href="mailto:nicholas.fabina@gmail.com"></a></div></li>
        <li><div class="github"><a href="https://github.com/nsfabina"></a></div></li>
        <li><div class="linkedin"><a href="https://linkedin.com/in/nsfabina"></a></div></li>
    </ul>
  </div>
</div>

<div id="content">
  <h5>How similar are Bernie Sanders' and Hillary Clinton's voting records?</h5>

  <p>The 2015 primary season is in full-swing and plenty of attention is being given to the two main Democratic candidates, Bernie Sanders and Hillary Clinton. Although there are clear differences between Sanders and Clinton, I thought it would be interesting to try to quantify those differences, and explore whether those differences were correlated with any meaningful characteristics. This actually seems like a pretty simple project, given the numerous efforts to open up government records and the tools available to evaluate this type of data.</p>

  <p>For this exploration, we're going to use the <a href="https://govtrack.us">GovTrack.us API</a> to access information on Sanders, Clinton, and other Senators. As an overview, we're going to <a href="#access_info">access Senator identifying information</a> and <a href="#access_votes">voting records</a>, <a href="#convert_data">convert that raw data</a> into useful structures, and <a href="#calculate_similarity">calculate</a> and <a href="#compare_similarity">compare similarity metrics</a>, much as we would for social network analysis or recommendation systems.

  <h5><a name="access_info">Accessing Senator information.</h5>

  <p>First, we need to pull a comprehensive list of Senators to analyze. I arbitrarily decided that I wanted to compare Senators that served after January 01, 2000, and I wanted to restrict the analysis to Senators that served for at least two years. Without confirming whether these constraints are useful, I wanted to avoid potential issues with temporal voting trends and changing political climates, as well as Senators that served for a short amount of time and have "outlier" voting records. With that in mind, we can pull identifying information for each Senator, including their GovTrack ID, name, party, state, and gender.</p>

  <pre class="prettyprint"><code class="block">import json
import requests

# Set the base GovTrack API URL
_URL_GOVTRACK = 'https://www.govtrack.us/api/v2/'
# Set the URL for Senator information, only search for Senators that match our 
# arbitrary criteria
url_senators = _URL_GOVTRACK + \
    'role?role_type=senator&enddate__gte=2002-01-01&limit=500'

# Access and load Senator information, careful to ensure that the number
# of senators does not exceed the API limit
senators_raw = json.loads(requests.get(url_senators).text)['objects']

# Clean Senator information, keeping only certain identifying details.
senators = {str(sen['person']['id']): {
                'name': sen['person']['name'],
                'lastname': sen['person']['lastname'],
                'firstname': sen['person']['firstname'],
                'party': sen['party'],
                'state': sen['state'],
                'gender': sen['person']['gender']}
            for sen in senators_raw}</code></pre>

  <p>At the time of this writing, this returns a dictionary with records for <code class="inline">201</code> Senators, each similar to this:</p>

  <pre class="prettyprint"><code class="block">bernie_id = [id_ for id_, sen in senators.items()
             if sen['lastname'] == 'Sanders' and
                 sen['firstname'] == 'Bernie'][0]
print senators[bernie_id]</code><samp>{'name': u'Sen. Bernard \u201cBernie\u201d Sanders [I-VT]',
 'firstname': u'Bernard', 
 'lastname': u'Sanders', 
 'state': u'VT', 
 'gender': u'male', 
 'party': u'Independent'}
  </samp></pre>

  <p>As an aside, I didn't have time to go very deep with this analysis. One could use the <a href="https://www.opensecrets.org">OpenSecrets.org</a> or the <a href="https://www.votesmart.org">VoteSmart.org</a> APIs (among others) to access additional information for each Senator. For instance, OpenSecrets.org has great information on net worth and funding, while VoteSmart.org has contextual data, including education and religious affiliation. GovTrack.us makes it easy to work with all three by providing the API IDs as 'osid' and 'vsid' in the raw response.</p>

  <h5><a name="access_votes">Accessing Senator voting records.</a></h5>

  <p>Second, we need to grab the votes for each Senator, but there are two tricky points here: one political and one technical. For the former, many Senators were also Representatives at one point and we do not want to incorrectly include Represenative votes in our analysis. For the latter, the GovTrack API has a limit of 600 objects (Senators, votes, bills, etc.) per each request, and we need to manually step through all API calls.</p>
  
  <pre class="prettyprint"><code class="block"># Set the base URL for Senator voting information, searching for only 
# votes made after Jan 01, 2000.
_URL_VOTERS = _URL_GOVTRACK + 'vote_voter?created__gt=2000-01-01'
_API_LIMIT = 600

# Functions to get all votes
def get_votes_for_senator(govtrack_id):
    """
    Get all votes for a Senator given his/her GovTrack ID.
    """
    # Get total vote count for the senator, used for paging
    total_count = _get_total_vote_count_for_senator(govtrack_id)
    # Create dictionary to hold votes
    votes = {}
    # Page through the API responses, get and clean vote information
    offsets = [idx * _API_LIMIT for idx in range(total_count / _API_LIMIT)]
    for offset in offsets:
        votes_raw = _get_raw_votes_for_senator(govtrack_id, offset)
        votes = _update_votes_with_raw_votes(votes, votes_raw)
    return votes

def _get_total_vote_count_for_senator(govtrack_id):
    """
    Get the total number of votes for a Senator given his/her GovTrack ID.
    """
    # URL for metainformation without records
    url_meta = _URL_VOTERS + '&person={id}&limit=0'.format(id=govtrack_id)
    # Access and load metainformation
    meta = json.loads(requests.get(url_meta).text)['meta']
    # Return vote count
    return meta['total_count']

def _get_raw_votes_for_senator(govtrack_id, offset):
    """
    Get a page of votes in the raw GovTrack API format.
    """
    # URL for votes, starting with vote number == offset
    url_votes = _URL_VOTERS + '&person={id}&offset={offset}&limit={limit}'\
        .format(id=govtrack_id, offset=offset, limit=_API_LIMIT)
    # Access, load, and return votes
    return json.loads(requests.get(url_votes).text)['objects']

def _update_votes_with_raw_votes(votes, votes_raw):
    """
    Update a dictionary of votes with GovTrack vote IDs and Senator vote 
    actions.
    """
    # Step through each raw vote
    for vote in votes_raw:
        # Keep the vote only if it was a Senate vote
        if vote['vote']['chamber_label'] == 'Senate':
            # Store the vote ID and Senator action
            vote_id = str(vote['vote']['id'])
            vote_action = vote['option']['value']
            votes.update({vote_id: vote_action})
    return votes</code></pre>

  <p>Whew, now we can actually get the votes for each Senator. This can take some time, depending on your setup, so you may find it helpful to track its progress. I usually prefer sending log statements to stdout when developing, but the print statements with a leading carriage return and a trailing comma are great for keeping progress statements to a single line.</p>

  <pre class="prettyprint"><code class="block"># Object to store votes
senator_votes = {}

# Get votes for each Senator
for idx, govtrack_id in enumerate(senators.keys()):
    print '\rGetting votes for Senator ', idx+1, ' out of ', len(senators),
    senator_votes.update({govtrack_id: get_votes_for_senator(govtrack_id)})</code></pre>

  <p>After that finishes, we have a dictionary of votes and vote actions for each Senator. For example, Bernie's votes look like:</p>

  <pre class="prettyprint"><code class="block">print senator_votes[bernie_id]</code><samp>{u'110004': u'Yea',
 u'110005': u'Yea',
 u'110007': u'Nay',
 u'110000': u'Yea',
 u'110001': u'Yea',
 u'114781': u'Yea',
 u'114780': u'Yea',
 u'16072': u'Yea',
 ...
}</samp></pre>

  <p></p>

  <h5><a name="convert_data">Preparing for analysis.</a></h5>

  <p>Okay, we now have Senator identifying information and voting records in two separate objects. Before proceeding, we want to create one derived object, a pandas dataframe, to format the data into something more amenable to exploration. Specifically, we'll create a matrix where Senators are columns, votes are rows, and the action taken by Senator <code class="inline">i</code> for vote <code class="inline">j</code> is represented by the <code class="inline">[i, j]</code> element. Fortunately, pandas is clever enough to handle this transformation for us.</p>

  <pre class="prettyprint"><code class="block">import pandas

votes = pandas.DataFrame(senator_votes)

keystone_xl_id = '116202'
print votes[bernie_id][keystone_xl_id]</code><samp>"Nay"</samp></pre>

  <p> So, for the example above, Bernie voted <code class="inline">Nay</code> on the Keystone XL bill from January 2015. One critical detail -- certainly not the only -- for our analysis is what actions were possible:</p>

  <pre class="prettyprint"><code class="block">print pandas.Series(votes.values.ravel()).unique()</code><samp>[nan u'Yea' u'Not Voting' u'Nay' u'Present' u'Not Guilty' u'Guilty']</samp></pre>

  <p></p>

  <h5><a name="calculate_similarity">Calculating similarity values.</a></h5>

  <p>Now that the formalities have been addressed, we can develop apply a similarity metric to the dataset. Remember, our goal is to evaluate the similarity of Senators' voting records. To illustrate the data we're evaluating, check out this subset of the pandas dataframe for Bernie and Hillary's columns:</p>

  <pre class="prettyprint"><code class="block">hillary_id = [id_ for id_, sen in senators.items()
    if sen['lastname'] == 'Clinton' and
        sen['firstname'] == 'Hillary'][0]

print votes.get([bernie_id, hillary_id])[1017:1025]</code><samp>      400357  300022
111248  Yea Yea
111250  Yea Yea
111251  Yea Yea
111254  Nay Nay
111255  Nay Nay
111260  Yea Yea
111264  Nay Yea
111266  Yea Not Voting</samp></pre>

  <p>Each row from the two columns is a datapoint to evaluate whether Bernie and Hillary are similar to one another. If you're comfortable with graph theory, social networks, or recommendation systems, this will look pretty familiar.</p>

  <p>Looking at the pair of actions in each datapoint or vote, we can see that Sanders and Clinton can 1) both vote <code class="inline">Yea</code>, 2) both vote <code class="inline">Nay</code>, 3) vote <code class="inline">Nay</code> and <code class="inline">Yea</code>, respectively, and 4) vote and not vote, respectively. Ignoring for a second that there are other possible responses, how can we use this information to calculate their similarity?</p>

  <p>Well, one way of addressing this question would be to count a point towards similarity if both Senators take the same action (both <code class="inline">Yea</code> or both <code class="inline">Nay</code>), a point towards dissimilarity if the two cast different votes (<code class="inline">Yea</code> and <code class="inline">Nay</code>), and to ignore the datapoint if at least one Senator did not vote (<code class="inline">nan</code> or <code class="inline">Not Voting</code>). Essentially, we're applying a modified Jaccard index to these two columns. Similarity values will range between <code class="inline">1</code> for Senators with identical voting records and <code class="inline">-1</code> for Senators who always took different voting actions.</p>

  <p>To make things even simpler, we're only going to count <code class="inline">Yea</code> and <code class="inline">Nay</code>, ignoring all other possible actions. It's not that we couldn't tease meaning from <code class="inline">Present</code> or <code class="inline">Not Voting</code>, such as Senators avoiding divisive votes during election years, but we would need to dig deeper to feel confident about their meaning. We're also going to require that each pair of Senators have at least 100 shared votes to evaluate their similarity, defaulting to <code class="inline">NA</code> if we don't have enough data.</p>

  <pre class="prettyprint"><code class="block">import numpy as np

# Require at least 100 shared votes
_THRESHOLD_VOTES = 100

# Function to calculate senator similarity
def calculate_senator_similarity(votes_i, votes_j):
    """
    Calculate the similarity of two Senators based on their voting records.
    """
    idx_overlap = \
        np.logical_and(
            np.logical_or(votes_i.values == 'Yea', votes_i.values == 'Nay'),
            np.logical_or(votes_j.values == 'Yea', votes_j.values == 'Nay'))
    same = np.sum(votes_i.values[idx_overlap] == votes_j.values[idx_overlap])
    diff = np.sum(votes_i.values[idx_overlap] != votes_j.values[idx_overlap])
    total = np.sum(idx_overlap)
    if total >= _THRESHOLD_VOTES:
        similarity = float(same - diff) / total
    else:
        similarity = None
    return similarity

# Step through Senators, only calculating once for each pair
similarities = {senator: {} for senator in votes.columns}

for idx_i, senator_i in enumerate(votes.columns):
    print '\rCalculating similarity for Senator ', idx_i+1, ' out of ', len(votes.columns),
    for idx_j, senator_j in enumerate(votes.columns):
        if idx_i < idx_j:
            votes_i = votes.get(senator_i)
            votes_j = votes.get(senator_j)
            similarity = calculate_senator_similarity(votes_i, votes_j)
            similarities[senator_i].update({senator_j: similarity})
            similarities[senator_j].update({senator_i: similarity})</code></pre>

  <p>Note that I calculated the similarity for each pair of Senators only once. We store the similarity value for Senators <code class="inline">i</code> and <code class="inline">j</code> twice, in case we'd like to use the indices in any order.</p>

  <p>Again, we'll make use of a pandas dataframe to format this dictionary. However, this matrix will have Senators as columns and rows, with each matrix element <code class="inline">[i, j]</code> representing the similarity between Senators <code class="inline">i</code> and <code class="inline">j</code>. As a reminder, we expect Senators to have no similarity value relative to Senators they share fewer than <code class="inline">100</code> votes with, as well as themselves given how we iterated through indices.</p>

  <pre class="prettyprint"><code class="block"># Convert similarities to a dataframe
similarities = pandas.DataFrame(similarities)</code></pre>

  <p></p>

  <h5><a name="compare_similarity">Analyzing similarity values.</a></h5>

  <p>Using this dataframe, we can easily see the similarity of any two Senators. For instance, the whole premise of this post was that we wanted to know how similar Bernie and Hillary were based on their voting record:</p>

  <pre class="prettyprint"><code class="block">print similarities[bernie_id][hillary_id]</code><samp>0.863905325444</samp></pre>

  <p>Given that this is essentially a modified recommendation system, this is the relative confidence that we think someone would support Hillary, given that they thought Bernie was a good Senator (or vice versa). That is, if a similarity value of <code class="inline">1</code> represents high confidence that someone would like a second Senator, given their preference for the first, <code class="inline">-1</code> would represent high confidence that someone would not like a second Senator, and <code class="inline">0</code> would represent complete uncertainty. Here, we're pretty confident that a Bernie supporter would also have no issue with voting for Hillary, and a Hillary supporter would just as easily cast a vote for Bernie.</p>

  <p>What about the Republicans? What's the chance that a Bernie or Hillary supporter would also support Ted Cruz, Lindsey Graham, Rand Paul, or Rick Santorum?</p>

  <pre class="prettyprint"><code class="block"># Get Republican GovTrack IDs
republicans = [('Ted', 'Cruz'), ('Lindsey', 'Graham'), ('Rand', 'Paul'),
               ('Richard', 'Santorum')]
r_ids = {sen['lastname']: id_ for id_, sen in senators.items()
         for republican in republicans
         if sen['firstname'] == republican[0] and 
            sen['lastname'] == republican[1]}

# Print similarity values
for r_name, r_id in r_ids.items():
    print 'Bernie and ' + r_name, similarities[bernie_id].loc[r_id][0]
    print 'Hillary and ' + r_name, similarities[hillary_id].loc[r_id][0], '\n'</code><samp>"Bernie and Paul" -0.435294117647
"Hillary and Paul" nan 

"Bernie and Santorum" nan
"Hillary and Santorum" -0.205555555556 

"Bernie and Graham" -0.300217864924
"Hillary and Graham" -0.232323232323 

"Bernie and Cruz" -0.441605839416
"Hillary and Cruz" nan</samp></pre>

  <p>There are two things we expect to see here. First, supporters of Bernie and Hillary are expected to not support any of the Republican candidates for President. Second, we cannot estimate the similarity between Bernie and Santorum, or between Hillary and Paul or Cruz, because their service did not overlap.</p>

  <p>We could infer unknown similarity values from known Senator similarities. For instance, Bernie joined the Senate in 2007, the same year that Santorum left. If we can find Senators that served both before and after 2007, we can compare their pre-2007 Santorum similarities to their post-2007 Bernie similarities. One of the simplest approaches would be looking at correlations in the Santorum and Bernie similarities. Positive correlations would suggest that Bernie and Santorum would have been similar, which negative correlations would suggest the opposite.</p>

  <pre class="prettyprint"><code class="block"># Find Senators that have a defined similarity to both Bernie and Santorum
bernie_similarities = similarities.get(bernie_id).values.flatten()
santorum_similarities = similarities.get(r_ids['Santorum']).values.flatten()
idx_shared = np.where(np.logical_and(np.isfinite(bernie_similarities),
                                     np.isfinite(santorum_similarities)))[0]

# Calculate the correlation between Bernie and Santorum similarities to other
Senators
import scipy.stats
scipy.stats.stats.pearsonr(bernie_similarities[idx_shared],
                           santorum_similarities[idx_shared])</code><samp>(-0.9467258490971735, 4.3346315945342932e-44)</samp></pre>

  <p>Ignoring any statistical or political issues with this type of analysis, the correlation between the similarity of Senators to Bernie and the similarity of Senators to Santorum is <code class="inline">-.94</code>, suggesting that Bernie and Santorum would have been dissimilar had their Senate service overlapped.</p>

  <p>Another way to look at this would be to ask which Senators have voting records most similar to Bernie or Hillary. Again, this is our relative estimate for which Senators someone might like, given that they like either Bernie or Hillary. For the political nerds amongst us, this makes a lot of sense given political and demographic trends.</p>

  <pre class="prettyprint"><code class="block">for id_, sim in similarities[bernie_id].order(ascending=False)[:10].iteritems():
    print senators[id_]['name'], sim</code><samp>u'Vice President Joseph Biden [D]' 0.94339622641509435
u'Sen. Tammy Baldwin [D-WI]' 0.92434988179669031
u'Sen. Edward \u201cEd\u201d Markey [D-MA]' 0.92047713717693835
u'Sen. Cory Booker [D-NJ]' 0.9196428571428571
u'Sen. Brian Schatz [D-HI]' 0.9135338345864662
u'Sen. Mazie Hirono [D-HI]' 0.91189427312775329
u'Sen. Elizabeth Warren [D-MA]' 0.9054290718038529
u'Sen. Patrick Leahy [D-VT]' 0.90335790335790334
u'Sen. Christopher Murphy [D-CT]' 0.89396170839469813
u'Sen. Roland Burris [D-IL, 2009-2010]' 0.89097103918228282</samp><code class="block">for id_, sim in similarities[hillary_id].order(ascending=False)[:10].iteritems():
    print senators[id_]['name'], sim</code><samp>u'Sen. Sherrod Brown [D-OH]' 0.92814371257485029
u'Sen. Benjamin Cardin [D-MD]' 0.91150442477876104
u'Sen. Charles \u201cChuck\u201d Schumer [D-NY]' 0.91003148897885744
u'Sen. Sheldon Whitehouse [D-RI]' 0.90588235294117647
u'President Barack Obama [D]' 0.88275084554678696
u'Sen. Frank Lautenberg [D-NJ, 2003-2013]' 0.8780641106222502
u'Sen. Robert \u201cBob\u201d Casey [D-PA]' 0.87683284457478006
u'Sen. John Kerry [D-MA, 1985-2013]' 0.87085514834205935
u'Sen. Barbara Mikulski [D-MD]' 0.86976320582877964
u'Sen. Barbara Boxer [D-CA]' 0.86894323950161512</samp></pre>

  <p>Using this information, we could also be pretty confident that a Bernie supporter would probably not be a fan of these Senators:</p>

  <pre class = "prettyprint"><code class="block">for id_, sim in similarities[bernie_id].order()[:10].iteritems():
    print senators[id_]['name'], sim</code><samp>u'Sen. Jim DeMint [R-SC, 2005-2012]' -0.58496476115896634
u'Sen. Jon Kyl [R-AZ, 1995-2012]' -0.5302218821729151
u'Sen. Thomas Coburn [R-OK, 2005-2014]' -0.52776481567895472
u'Sen. Tim Scott [R-SC]' -0.49025487256371814
u'Sen. Jim Bunning [R-KY, 1999-2010]' -0.48693586698337293
u'Sen. Mike Lee [R-UT]' -0.48633879781420764
u'Sen. James \u201cJim\u201d Inhofe [R-OK]' -0.47698924731182796
u'Sen. James Risch [R-ID]' -0.46511627906976744
u'Sen. John Ensign [R-NV, 2001-2011]' -0.46146146146146144
u'Sen. Ted Cruz [R-TX]' -0.44160583941605841</samp></pre>

  <p>That's interesting and all, but we can do so much more with the data we've gathered. All of the comparisons above are pairwise; that is, they only account for the relationship between any two Senators. We can use the overall structure of this matrix, which is essentially a social network with weights representing political similarity, to explore groupings and other large-scale patterns. That'll be coming in my next post.</p>
</div>

</body>

</html>
